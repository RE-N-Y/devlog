---
import '../styles/global.css'
import BaseHead from "@/src/components/BaseHead.astro"
import { SITE_TITLE, SITE_DESCRIPTION, PREVIEW_IMAGE } from "@/src/consts"

import clsx from "clsx"
const _class = Astro.props.class
---

<!DOCTYPE html>
<html lang="en">
	<head>
		<BaseHead title={SITE_TITLE} description={SITE_DESCRIPTION} image={PREVIEW_IMAGE} />
	</head>
	<body>
		<div id="canvas" class="fixed top-0 left-0 w-full h-full" style="z-index: -10;"></div>
		<div class="fixed top-0 left-0 z-0 w-full h-full backdrop-blur-md bg-white/5"></div>
		<main class={clsx("h-screen relative z-10", _class)}>
			<slot />
		</main>
		<script>
		import { Water } from '@/src/components/Water.js';
		import * as THREE from 'three';

		// Animation
		const clock = new THREE.Clock();

		// Scene setup
		const scene = new THREE.Scene();
		const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
		const renderer = new THREE.WebGLRenderer({ antialias: true });

		renderer.setSize(window.innerWidth, window.innerHeight);
		document.getElementById('canvas').appendChild(renderer.domElement);

		// Position camera
		camera.position.z = 5;

		const water = new Water({
			resolution: 1024,
			flowStrength: 0.01,
			grid: 12,
			animationSpeed: 0.001,
			noiseScale: 8.0,
			timeScale: 0.1,
			displacementStrength: 0.03,
			primaryFoamIntensity: 12.0,
			primaryShadowIntensity: 0.35,
			secondaryFoamIntensity: 0.35,
		});

		// Update shader resolution to match actual canvas size
		water.material.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);

		// Scale plane to cover full screen
		const aspect = window.innerWidth / window.innerHeight;
		const fov = camera.fov * Math.PI / 180; // Convert to radians
		const planeHeight = 2 * Math.tan(fov / 2) * camera.position.z;
		const planeWidth = planeHeight * aspect;
		water.scale.set(planeWidth, planeHeight, 1);

		scene.add(water);

		// Animation loop
		function animate() {
			requestAnimationFrame(animate);
			
			// Update time
			const time = clock.getElapsedTime();
			water.material.uniforms.uTime.value = time;
			renderer.render(scene, camera);
		}

		// Handle window resize
		window.addEventListener('resize', () => {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
			water.material.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
			
			// Recalculate plane scaling
			const aspect = window.innerWidth / window.innerHeight;
			const fov = camera.fov * Math.PI / 180;
			const planeHeight = 2 * Math.tan(fov / 2) * camera.position.z;
			const planeWidth = planeHeight * aspect;
			water.scale.set(planeWidth, planeHeight, 1);
		});

		// Start animation
		animate();
		</script>
	</body>
</html>